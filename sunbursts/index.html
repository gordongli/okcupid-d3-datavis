<DOCTYPE html>
<head>
<script src="//d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="helpers.js"></script>
<script src="tooltip.js"></script>

<link href="../style.css" rel="stylesheet" type="text/css">

<style>
svg { border: solid 1px #333; }
/*div#vis {
  text-align: center;
}*/

</style>
</head>

<body>
<div id="vis">
</div>

<script>

d3.csv("simple_pivot_cleaned_profiles_noessay.csv", function(error, data) {

  console.log("data", data);

  var leaves = data.map(function(d) {
    var n = {};
    n.value = +d.row_count;
    n.label = d.ethnicity; // for nice tooltips
    // id is used by stratify to represent the current node
    n.id = [d.sex, d.orientation, d.education, d.ethnicity].join("-");
    // parentID is used by stratify to represent the parent node (should match the id of another node eventually)
    n.parentId = [d.sex, d.orientation, d.education].join("-")
    return n;
  });
  console.log("leaves", leaves);


  // grab all the unique values so we can create inner nodes
  var unique = {};
  unique.sex = d3.set(data, function(d) { return d.sex; });
  unique.orientation = d3.set(data, function(d) { return d.orientation; });
  unique.education = d3.set(data, function(d) { return d.education; });
  unique.ethnicity = d3.set(data, function(d) { return d.ethnicity; });
  console.log("unique", unique);

  // start with a fake root
  var innerNodes = [{
    id: "root",
    label: "root"
  }];

  // add one node for each sex, then for each sex/orientation combo, etc. etc.
  unique.sex.each(function(s) {
    innerNodes.push({ id: s, label: s, parentId: "root"});

    unique.orientation.each(function(o) {
      innerNodes.push({
        id: s + "-" + o,
        label: o,
        parentId: s
      });

      unique.education.each(function(ed) {
        innerNodes.push({
          id: s + "-" + o + "-" + ed,
          label: ed,
          parentId: s + "-" + o
        });
      });
    });
  });
  console.log("innerNodes", innerNodes);

  var root = innerNodes.concat(leaves);
  console.log("root", root);

  // then this should work to generate a hierarchy
  // var stratified = d3.stratify()(innerNodes.concat(leaves));
  var stratified = d3.stratify()(root);
  console.log("stratified", stratified);

  var summed = stratified.sum(function(d) { return d.value; });
  console.log("summed", summed);

  var partitioned = d3.partition()(summed);
  console.log("partitioned", partitioned);

  var arc = d3.arc()
    .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x0))); })
    .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x1))); })
    .innerRadius(function(d) { return Math.max(0, y(d.y0)); })
    .outerRadius(function(d) { return Math.max(0, y(d.y1)); });


  // configure size, margin, and circle radius
  var config = {
      w: 640,
      h: 640,
      r: 4,
      pad: 20
  };

  // maximum diameter of circle is minimum dimension
  config.d = Math.min(config.w, config.h);

  // used to color node by depth
  var color = d3.scaleOrdinal();
  // setup color scale
  color.domain(d3.range(stratified.height + 1));
  // color.range(d3.schemeYlGnBu[root.height + 1]);
  color.range(d3.schemeSpectral[stratified.height + 1].reverse());

  var svg = d3.select("div#vis").append("svg");
  svg.attr("width", config.w);
  svg.attr("height", config.h);

  var g = svg.append("g");
  g.attr("id", "plot");
  // g.attr("transform", translate(config.pad, config.pad));

  // translate so circle is in middle of plot area
  // var xshift = config.pad/2 + (config.w) / 2;
  // var yshift = config.pad/2 + (config.h) / 2;
  var xshift = config.w / 2;
  var yshift = config.h / 2;
  g.attr("transform", translate(xshift, yshift));

  var diameter = config.d - 2 * config.pad;
  var radius = diameter / 2;

  var x = d3.scaleLinear()
    .range([0, 2 * Math.PI]);

  var y = d3.scaleSqrt()
    .range([0, radius]);

  var arcs = g.selectAll("path")
          .data(partitioned.descendants())
        .enter().append("path")
          .attr("d", arc)
          .attr("class", "node")
          .attr("id", function(d) { return d.data.id; })
          .style("fill", function(d) { return color(d.depth)})
          .on("mouseover.tooltip", function(d) {
            show_tooltip(g, d3.select(this));
            d3.select(this).classed("selected", true);
            d3.select(this).raise();
          })
          .on("mouseout.tooltip", function(d) {
            g.select("#tooltip").remove();
            d3.select(this).classed("selected", false);
          });

});

</script>

</body>
