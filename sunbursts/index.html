<DOCTYPE html>
<head>
<script src="//d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="helpers.js"></script>
<script src="tooltip.js"></script>

<link href="../style.css" rel="stylesheet" type="text/css">

<style>
svg { border: solid 1px #333; }
/*div#vis {
  text-align: center;
}*/

</style>
</head>

<body>
<div id="vis">
</div>

<script>

d3.csv("simple_pivot_cleaned_profiles_noessay.csv", function(error, data) {

  console.log("data", data);

  var leaves = data.map(function(d) {
    var n = {};
    n.value = +d.row_count;
    n.label = d.ethnicity; // for nice tooltips
    // id is used by stratify to represent the current node
    n.id = [d.sex, d.orientation, d.education, d.ethnicity].join("-");
    // parentID is used by stratify to represent the parent node (should match the id of another node eventually)
    n.parentId = [d.sex, d.orientation, d.education].join("-")
    return n;
  });
  console.log("leaves", leaves);


  var leaves1 = data.map(function(d) {
    var n = {};
    n.value = +d.row_count;
    n.label = d.education; // for nice tooltips
    // id is used by stratify to represent the current node
    n.id = [d.sex, d.ethnicity, d.education].join("-");
    // parentID is used by stratify to represent the parent node (should match the id of another node eventually)
    n.parentId = [d.sex, d.ethnicity].join("-")
    return n;
  });
  console.log("leaves1", leaves1);

  // grab all the unique values so we can create inner nodes
  var unique = {};
  unique.sex = d3.set(data, function(d) { return d.sex; });
  unique.orientation = d3.set(data, function(d) { return d.orientation; });
  unique.education = d3.set(data, function(d) { return d.education; });
  unique.ethnicity = d3.set(data, function(d) { return d.ethnicity; });
  console.log("unique", unique);

  // grab all the unique values so we can create inner nodes
  var unique1 = {};
  unique1.sex = d3.set(data, function(d) { return d.sex; });
  // unique.orientation = d3.set(data, function(d) { return d.orientation; });
  unique1.education = d3.set(data, function(d) { return d.education; });
  unique1.ethnicity = d3.set(data, function(d) { return d.ethnicity; });
  console.log("unique1", unique1);


  // start with a fake root
  var innerNodes = [{
    id: "root",
    label: "root"
  }];
  // add one node for each sex, then for each sex/orientation combo, etc. etc.
  unique.sex.each(function(s) {
    innerNodes.push({ id: s, label: s, parentId: "root"});

    unique.orientation.each(function(o) {
      innerNodes.push({
        id: s + "-" + o,
        label: o,
        parentId: s
      });

      unique.education.each(function(ed) {
        innerNodes.push({
          id: s + "-" + o + "-" + ed,
          label: ed,
          parentId: s + "-" + o
        });
      });
    });
  });
  console.log("innerNodes", innerNodes);


  // start with a fake root
  var innerNodes1 = [{
    id: "root",
    label: "root"
  }];
  // add one node for each sex, then for each sex/orientation combo, etc. etc.
  unique1.sex.each(function(s) {
    innerNodes1.push({ id: s, label: s, parentId: "root"});

    unique1.ethnicity.each(function(et) {
      innerNodes1.push({
        id: s + "-" + et,
        label: et,
        parentId: s
      });


      unique1.education.each(function(ed) {
          innerNodes1.push({
            id: s + "-" + et + "-" + ed,
            label: ed,
            parentId: s + "-" + et
          });
        });
    });
    // unique.orientation.each(function(o) {
    //   innerNodes.push({
    //     id: s + "-" + o,
    //     label: o,
    //     parentId: s
    //   });
    //
    //   unique.education.each(function(ed) {
    //     innerNodes.push({
    //       id: s + "-" + o + "-" + ed,
    //       label: ed,
    //       parentId: s + "-" + o
    //     });
    //   });
    // });

  });
  console.log("innerNodes1", innerNodes1);


  var root = innerNodes.concat(leaves);
  console.log("root", root);


  var root1 = innerNodes1.concat(leaves1);
  console.log("root1", root1);



  // then this should work to generate a hierarchy
  // var stratified = d3.stratify()(innerNodes.concat(leaves));
  var stratified = d3.stratify()(root);
  console.log("stratified", stratified);

  // then this should work to generate a hierarchy
  var stratified1 = d3.stratify()(root1);
  console.log("stratified1", stratified1);

  var summed = stratified.sum(function(d) { return d.value; });
  console.log("summed", summed);

  var summed1 = stratified1.sum(function(d) { return d.value; });
  console.log("summed1", summed1);

  var partitioned = d3.partition()(summed);
  console.log("partitioned", partitioned);

  var partitioned1 = d3.partition()(summed1);
  console.log("partitioned1", partitioned1);



  // configure size, margin, and circle radius
  var config = {
      w: 640,
      h: 640,
      r: 4,
      pad: 20
  };

  // maximum diameter of circle is minimum dimension
  config.d = Math.min(config.w, config.h);

  var svg = d3.select("div#vis").append("svg");
  svg.attr("width", config.w);
  svg.attr("height", config.h);

  var g = svg.append("g");
  g.attr("id", "plot");
  // g.attr("transform", translate(config.pad, config.pad));

  // translate so circle is in middle of plot area
  // var xshift = config.pad/2 + (config.w) / 2;
  // var yshift = config.pad/2 + (config.h) / 2;
  var xshift = config.w / 2;
  var yshift = config.h / 2;
  g.attr("transform", translate(xshift, yshift));

  var diameter = config.d - 2 * config.pad;
  var radius = diameter / 2;

  var x = d3.scaleLinear()
    .range([0, 2 * Math.PI]);

  var y = d3.scaleSqrt()
    .range([0, radius]);


    /*
      // used to color node by depth
      var color = d3.scaleOrdinal();
      // setup color scale
      color.domain(d3.range(stratified.height + 1));
      // color.range(d3.schemeYlGnBu[root.height + 1]);
      color.range(d3.schemeSpectral[stratified.height + 1].reverse());
    */

      // unique.orientation.each(function(category) {
      //   console.log(category);
      // })
      var color = d3.scaleOrdinal()
      color.domain([
        "m","f",
        "straight", "gay", "bisexual",
        "college", "less than college", "more than college", "NA",
        "white", "other", "asian", "hispanic", "black",
      ]);
      color.range([
        // "red", "blue",
        "rgb(56,109,164)", "rgb(215,61,61)",
        "blue", "pink", "purple",
        "green", "gold", "orange", "gray",
        "white", "gray", "yellow", "brown", "black"
      ]);

      var color1 = d3.scaleOrdinal()
      color1.domain([
        "m","f",
        "college", "less than college", "more than college", "NA",
        "white", "other", "asian", "hispanic", "black",
      ]);
      color1.range([
        "rgb(56,109,164)", "rgb(215,61,61)",
        "hsl(120, 45%, 70%)", "hsl(120, 45%, 90%)", "hsl(120, 45%, 50%)", "#e6e6e6",
        "#ffdbac", "#e6e6e6", "#f1c27d", "#c68642", "#8d5524"
      ]);



  var arc = d3.arc()
    .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x0))); })
    .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x1))); })
    .innerRadius(function(d) { return Math.max(0, y(d.y0)); })
    .outerRadius(function(d) { return Math.max(0, y(d.y1)); });


  // var arcs = g.selectAll("path")
  //         .data(partitioned.descendants())
  //       .enter().append("path")
  //         .attr("d", arc)
  //         .attr("class", "node")
  //         .attr("id", function(d) { return d.data.id; })
  //         .style("fill", function(d) { return color(d.data.label)})
  //         // .style("fill", function(d) { return color(d.depth)})
  //         .on("mouseover.tooltip", function(d) {
  //           show_tooltip(g, d3.select(this));
  //           d3.select(this).classed("selected", true);
  //           d3.select(this).raise();
  //         })
  //         .on("mouseout.tooltip", function(d) {
  //           g.select("#tooltip").remove();
  //           d3.select(this).classed("selected", false);
  //         });

  var arcs1 = g.selectAll("path")
        .data(partitioned1.descendants())
          // .data(partitioned1.descendants())
        .enter().append("path")
          .attr("d", arc)
          .attr("class", "node")
          .attr("id", function(d) { return d.data.id + ": " + d3.format(",")(d.value); })
          .style("fill", function(d) { return color1(d.data.label)})
          // .style("fill", function(d) { return color(d.depth)})
          .on("mouseover.tooltip", function(d) {
            show_tooltip(g, d3.select(this));
            d3.select(this).classed("selected", true);
            d3.select(this).raise();
          })
          .on("mouseout.tooltip", function(d) {
            g.select("#tooltip").remove();
            d3.select(this).classed("selected", false);
          });

  console.log(arcs1);
  console.log(d3.selectAll("div#vis path#root"));

  d3.selectAll("div#vis path#root").style("fill", "#e6e6e6");

});

</script>

</body>
