<DOCTYPE html>
<head>
<script src="//d3js.org/d3.v4.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<script src="helpers.js"></script>
<script src="tooltip.js"></script>

<link href="../style.css" rel="stylesheet" type="text/css">

<style>
/*svg { border: solid 1px #333; }*/
/*div#vis {
  text-align: center;
}*/

</style>
</head>

<body>
<div id="vis">
</div>

<script>

// d3.csv("simple_pivot_cleaned_profiles_noessay.csv", function(error, data) {
d3.csv("eth_edu_pivot_profiles.csv", function(error, data) {

  console.log("data", data);


  var leaves = data.map(function(d) {
    var n = {};
    n.value = +d.row_count;
    n.label = d.education; // for nice tooltips
    // id is used by stratify to represent the current node
    n.id = [d.sex, d.ethnicity, d.education].join("-");
    // parentID is used by stratify to represent the parent node (should match the id of another node eventually)
    n.parentId = [d.sex, d.ethnicity].join("-")
    return n;
  });
  console.log("leaves", leaves);


  // grab all the unique values so we can create inner nodes
  var unique = {};
  unique.sex = d3.set(data, function(d) { return d.sex; });
  unique.education = d3.set(data, function(d) { return d.education; });
  unique.ethnicity = d3.set(data, function(d) { return d.ethnicity; });
  console.log("unique1", unique);


  // start with a fake root
  var innerNodes = [{
    id: "root",
    label: "root"
  }];
  // add one node for each sex, then for each sex/orientation combo, etc. etc.
  unique.sex.each(function(s) {
    innerNodes.push({ id: s, label: s, parentId: "root"});

    unique.ethnicity.each(function(et) {
      innerNodes.push({
        id: s + "-" + et,
        label: et,
        parentId: s
      });


      unique.education.each(function(ed) {
          innerNodes.push({
            id: s + "-" + et + "-" + ed,
            label: ed,
            parentId: s + "-" + et
          });
        });
    });
  });
  console.log("innerNodes", innerNodes);

  var root = innerNodes.concat(leaves);
  console.log("root", root);

  // then this should work to generate a hierarchy
  var stratified = d3.stratify()(root);
  console.log("stratified", stratified);

  var summed = stratified.sum(function(d) { return d.value; });
  console.log("summed", summed);

  var partitioned = d3.partition()(summed);
  console.log("partitioned", partitioned);



  // configure size, margin, and circle radius
  var config = {
      w: 640,
      h: 640,
      r: 4,
      pad: 20
  };

  // maximum diameter of circle is minimum dimension
  config.d = Math.min(config.w, config.h);

  var svg = d3.select("div#vis").append("svg");
  svg.attr("id", "sunburst1");
  svg.attr("width", config.w);
  svg.attr("height", config.h);

  var g = svg.append("g");
  g.attr("id", "plot");
  // g.attr("transform", translate(config.pad, config.pad));

  // translate so circle is in middle of plot area
  // var xshift = config.pad/2 + (config.w) / 2;
  // var yshift = config.pad/2 + (config.h) / 2;
  var xshift = config.w / 2;
  var yshift = config.h / 2;
  g.attr("transform", translate(xshift, yshift));

  var diameter = config.d - 2 * config.pad;
  var radius = diameter / 2;

  var x = d3.scaleLinear()
    .range([0, 2 * Math.PI]);

  var y = d3.scaleSqrt()
    .range([0, radius]);


      var color = d3.scaleOrdinal()
      color.domain([
        "m","f",
        "college", "less than college", "more than college", "NA",
        "white", "other", "asian", "hispanic", "black",
      ]);
      color.range([
        "rgb(56,109,164)", "rgb(215,61,61)",
        'rgb(161,217,155)','rgb(229,245,224)','rgb(49,163,84)', "#e6e6e6",
        // "hsl(120, 45%, 70%)", "hsl(120, 45%, 90%)", "hsl(120, 45%, 50%)", "#e6e6e6",
        // 'rgb(173,221,142)','rgb(247,252,185)','rgb(49,163,84)', "#e6e6e6",
        "#ffdbac", "#e6e6e6", "#f1c27d", "#c68642", "#8d5524"
      ]);



  var arc = d3.arc()
    .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x0))); })
    .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x1))); })
    .innerRadius(function(d) { return Math.max(0, y(d.y0)); })
    .outerRadius(function(d) { return Math.max(0, y(d.y1)); });


  var arcs = g.selectAll("path")
        .data(partitioned.descendants())
        .enter().append("path")
          .attr("d", arc)
          .attr("class", "node")
          .attr("id", function(d) { return d.data.id; })
          // .attr("id", function(d) { return d.data.id + ": " + d3.format(",")(d.value); })
          .style("fill", function(d) { return color(d.data.label)})
          // .style("fill", function(d) { return color(d.depth)})
          .on("mouseover.tooltip", function(d) {
            show_tooltip(g, d3.select(this));
            d3.select(this).classed("selected", true);
            d3.select(this).raise();
          })
          .on("mouseout.tooltip", function(d) {
            g.select("#tooltip").remove();
            d3.select(this).classed("selected", false);
          });

  d3.selectAll("div#vis path#root").style("fill", "#e6e6e6");

});

</script>
<script>
d3.csv("ori_rel_pivot_profiles.csv", function(error, data) {

  console.log("data", data);

  var leaves = data.map(function(d) {
    var n = {};
    n.value = +d.row_count;
    n.label = d.religion; // for nice tooltips
    // id is used by stratify to represent the current node
    n.id = [d.sex, d.orientation, d.religion].join("-");
    // parentID is used by stratify to represent the parent node (should match the id of another node eventually)
    n.parentId = [d.sex, d.orientation].join("-")
    return n;
  });
  console.log("leaves", leaves);


  // grab all the unique values so we can create inner nodes
  var unique = {};
  unique.sex = d3.set(data, function(d) { return d.sex; });
  unique.orientation = d3.set(data, function(d) { return d.orientation; });
  unique.religion = d3.set(data, function(d) { return d.religion; });
  console.log("unique", unique);

  // start with a fake root
  var innerNodes = [{
    id: "root",
    label: "root"
  }];
  // add one node for each sex, then for each sex/orientation combo, etc. etc.
  unique.sex.each(function(s) {
    innerNodes.push({ id: s, label: s, parentId: "root"});

    unique.orientation.each(function(o) {
      innerNodes.push({
        id: s + "-" + o,
        label: o,
        parentId: s
      });


      unique.religion.each(function(r) {
          innerNodes.push({
            id: s + "-" + o + "-" + r,
            label: r,
            parentId: s + "-" + o
          });
        });
    });

  });
  console.log("innerNodes", innerNodes);


  var root = innerNodes.concat(leaves);
  console.log("root", root);

  // then this should work to generate a hierarchy
  var stratified = d3.stratify()(root);
  console.log("stratified", stratified);

  var summed = stratified.sum(function(d) { return d.value; });
  console.log("summed", summed);

  var partitioned = d3.partition()(summed);
  console.log("partitioned", partitioned);



  // configure size, margin, and circle radius
  var config = {
      w: 640,
      h: 640,
      r: 4,
      pad: 20
  };

  // maximum diameter of circle is minimum dimension
  config.d = Math.min(config.w, config.h);

  var svg = d3.select("div#vis").append("svg");
  svg.attr("id", "sunburst2");
  svg.attr("width", config.w);
  svg.attr("height", config.h);

  var g = svg.append("g");
  g.attr("id", "plot");
  // g.attr("transform", translate(config.pad, config.pad));

  // translate so circle is in middle of plot area
  // var xshift = config.pad/2 + (config.w) / 2;
  // var yshift = config.pad/2 + (config.h) / 2;
  var xshift = config.w / 2;
  var yshift = config.h / 2;
  g.attr("transform", translate(xshift, yshift));

  var diameter = config.d - 2 * config.pad;
  var radius = diameter / 2;

  var x = d3.scaleLinear()
    .range([0, 2 * Math.PI]);

  var y = d3.scaleSqrt()
    .range([0, radius]);


      unique.religion.each(function(category) {
        console.log(category);
      })
      var color = d3.scaleOrdinal()
      color.domain([
        "m","f",
        "straight", "gay", "bisexual",
        "agnosticism|atheism", "buddhism|hinduism", "christianity|catholicism", "judaism|islam", "NA|other"
      ]);
      color.range([
        "rgb(56,109,164)", "rgb(215,61,61)",
        'rgb(179,205,227)','rgb(244,202,228)','rgb(222,203,228)',
        // 'rgb(240,240,240)','rgb(189,189,189)','rgb(99,99,99)',
        // 'rgb(179,205,227)','rgb(140,150,198)','rgb(136,86,167)',
        // "darkgray", "lightgray", "gray",
        'rgb(251,180,174)','rgb(253,174,97)','rgb(255,255,191)','rgb(166,217,106)',"#e6e6e6"
      ]);


  var arc = d3.arc()
    .startAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x0))); })
    .endAngle(function(d) { return Math.max(0, Math.min(2 * Math.PI, x(d.x1))); })
    .innerRadius(function(d) { return Math.max(0, y(d.y0)); })
    .outerRadius(function(d) { return Math.max(0, y(d.y1)); });

  var arcs = g.selectAll("path")
        .data(partitioned.descendants())
        .enter().append("path")
          .attr("d", arc)
          .attr("class", "node")
          .attr("id", function(d) { return d.data.id; })
          // .attr("id", function(d) { return d.data.id + ": " + d3.format(",")(d.value); })
          .style("fill", function(d) { return color(d.data.label)})
          // .style("fill", function(d) { return color(d.depth)})
          .on("mouseover.tooltip", function(d) {
            show_tooltip(g, d3.select(this));
            d3.select(this).classed("selected", true);
            d3.select(this).raise();
          })
          .on("mouseout.tooltip", function(d) {
            g.select("#tooltip").remove();
            d3.select(this).classed("selected", false);
          });

  d3.selectAll("div#vis path#root").style("fill", "#e6e6e6");

});

</script>

</body>
