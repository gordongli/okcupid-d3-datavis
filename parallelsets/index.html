<DOCTYPE html>
<head>
<script src="//d3js.org/d3.v4.js"></script>

<style>
svg { border: solid 1px #333; margin: 0px;}
#visdiv {
  text-align: center;
}

</style>
</head>

<body>
<div id="visdiv">
</div>

<script>

d3.csv("simple_pivot_cleaned_profiles_noessay.csv", function(error, data) {

  console.log("data", data);

  var margin = {top: 20, right: 20, bottom: 20, left: 20};
  var svgWidth = 960;
  var svgHeight = 640;
  var width = svgWidth - margin.left - margin.right;
  var height = svgHeight - margin.top - margin.bottom;
  var categoryMargin = 30;

  var g = d3.select("#visdiv").append("svg")
      .attr("class", "parsets")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("class", "plot")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  var x = d3.scaleLinear().range([0, width]);
  var y = d3.scaleLinear().range([height, 0]);

  var nestS = d3.nest()
    .key(function(d) { return d.sex; })
    .rollup(function(leaves) { return d3.sum(leaves, function(d) {return d.row_count; }) })
    .entries(data);
  console.log("nestS", nestS);

  var total = 0;
  nestS.forEach(function(d) {
    total += d.value;
  })

  x.domain([0, total]);

  function drawDimension(dimensionNum, numDimensions, categories) {
    var margin = categoryMargin / categories.length;
    var offset = 0;
    var categoryNum;
    for (categoryNum = 0; categoryNum < categories.length; categoryNum++) {
      g.append("g")
        .attr("class", "category")
        .attr("id", categories[categoryNum].key)
        .attr("value", categories[categoryNum].value)
        .append("line")
          .attr("x1", function() {
            if (categoryNum == 0) { return 0; }
            else {
              offset = 0;
              var prevCategoryNum;
              for (prevCategoryNum = 0; prevCategoryNum < categoryNum; prevCategoryNum++) {
                offset += x(categories[prevCategoryNum].value);
              }
              return offset + margin;
            }
          })
          // this should take the margin added to x1 into account
          .attr("x2", offset + x(categories[categoryNum].value))
          .attr("y1", (height/(numDimensions-1))*(dimensionNum-1))
          .attr("y2", (height/(numDimensions-1))*(dimensionNum-1))
          .attr("style", "stroke:rgb(0,0,0); stroke-width:2");
    }
  };


  drawDimension(1, 4, nestS);

  var nestO = d3.nest()
    .key(function(d) { return d.orientation; })
    .rollup(function(leaves) { return d3.sum(leaves, function(d) {return d.row_count; }) })
    .entries(data);
  console.log("nestO", nestO);

  drawDimension(2, 4, nestO);


  var nestEd = d3.nest()
    .key(function(d) { return d.education; })
    .rollup(function(leaves) { return d3.sum(leaves, function(d) {return d.row_count; }) })
    .entries(data);
  console.log("nestEd", nestEd);

  drawDimension(3, 4, nestEd);

  var nestEt = d3.nest()
    .key(function(d) { return d.ethnicity; })
    .rollup(function(leaves) { return d3.sum(leaves, function(d) {return d.row_count; }) })
    .entries(data);
  console.log("nestEt", nestEt);

  drawDimension(4, 4, nestEt);


  // var categories = document.querySelectorAll(".category");
  //
  // categories.forEach(function(category) {
  //   var line = category.querySelector("line");
  //   var textElement = document.createElement("text");
  //   var textNode = document.createTextNode(category.getAttribute("id"));
  //   textElement.setAttribute("x", line.getAttribute("x1"));
  //   textElement.setAttribute("y", line.getAttribute("y1"));
  //   textElement.style.fill = "red";
  //   textElement.style.fontSize = 10;
  //   textElement.appendChild(textNode);
  //   category.appendChild(textElement);
  // })


  // var categories = d3.selectAll(".category");
  // // console.log(categories._groups);
  //
  // categories._groups.forEach(function(category) {
  //   console.log(category);
  // })


  // d3.selectAll(".category")
  //   .append("text")
  //   .x(d3.select(this).select("line").attr("x1"))
  //   .y(d3.select(this).select("line").attr("y1"))
  //   .text(d3.select(this).attr("id"));


  var nestSO = d3.nest()
    .key(function(d) { return d.sex; })
    .key(function(d) { return d.orientation; })
    .rollup(function(leaves) { return d3.sum(leaves, function(d) {return d.row_count; }) })
    .entries(data);

  console.log("nestSO", nestSO);

  // nestSO.forEach(function(gender) {
  //   console.log(gender);
  //   var genderG = d3.select("#" + gender.key)
  //   console.log(genderG);
  //   gender.values.forEach(function(orientation) {
  //     var orientationG = d3.select("#" + orientation.key)
  //     console.log(orientation);
  //     console.log(orientationG);
  //   })
  // });

  var nestSOEd = d3.nest()
    .key(function(d) { return d.sex; })
    .key(function(d) { return d.orientation; })
    .key(function(d) { return d.education; })
    .rollup(function(leaves) { return d3.sum(leaves, function(d) {return d.row_count; }) })
    .entries(data);

  console.log("nestSOEd", nestSOEd);


  var nestSOEdEt = d3.nest()
    .key(function(d) { return d.sex; })
    .key(function(d) { return d.orientation; })
    .key(function(d) { return d.education; })
    .key(function(d) { return d.ethnicity; })
    .rollup(function(leaves) { return d3.sum(leaves, function(d) {return d.row_count; }) })
    .entries(data);

  console.log("nestSOEdEt", nestSOEdEt);


  nestSOEdEt.forEach(function(sexN) {
    // console.log(sexN.key);
    nestS.forEach(function(sex) {
      if (sex.key === sexN.key)
        sexN.total = sex.values;
      });
  });

    console.log("nestSOEdEt", nestSOEdEt);
  // data = d3.nest()
  //   .key(function(d) { return d.sex; })
  //   .key(function(d) { return d.orientation; })
  //   .key(function(d) { return d.ethnicity; })
  //   .rollup(function(leaves) { return d3.sum(leaves, function(d) {return d.row_count; }) })
  //   .entries(data);
  //
  // console.log("data nested", data);

});

</script>

</body>
